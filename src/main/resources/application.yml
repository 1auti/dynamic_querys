# Mapeo de provincias a datasources (ESENCIAL para el RepositoryFactory)
provincia:
  mapping:
    "Buenos Aires": pba
    "Avellaneda": mda
    "La Pampa": santa-rosa
    "Chaco": chaco
    "Entre Ríos": entre-rios
    "Formosa": formosa

# =============== CONFIGURACIÓN DE BASES DE DATOS ===============
spring:
  datasource:
    jdbc-url: ${H2_URL:jdbc:h2:file:./data/query_metadata}
    username: ${H2_USERNAME:sa}
    password: ${H2_PASSWORD:}
    driver-class-name: org.h2.Driver
    hikari:
      pool-name: "H2-QueryMetadata-Pool"
      maximum-pool-size: 10
      minimum-idle: 2
      connection-timeout: 10000
      idle-timeout: 600000
      max-lifetime: 1800000

  # === CONFIGURACIÓN JPA/H2 ===
  jpa:
    hibernate:
      ddl-auto: update                    # Crear tablas automáticamente
    show-sql: ${SHOW_SQL:false}           # Solo en desarrollo
    properties:
      hibernate:
        jdbc:
          batch_size: 100           # Para batch inserts
          fetch_size: 1000          # Para streaming de resultados
          order_inserts: true         # CRÍTICO para batching
          order_updates: true
        dialect: org.hibernate.dialect.H2Dialect
        format_sql: true
        use_sql_comments: true
    database-platform: org.hibernate.dialect.H2Dialect

  # === CONSOLA H2 (Para debugging) ===
  h2:
    console:
      enabled: ${H2_CONSOLE_ENABLED:true}  # Habilitar en desarrollo
      path: /h2-console
      settings:
        web-allow-others: ${H2_WEB_ALLOW_OTHERS:false}
        trace: false

  # Configuración HTTP y Tomcat
  servlet:
    multipart:
      max-file-size: 50MB
      max-request-size: 50MB

  # Jackson JSON limits
  jackson:
    deserialization:
      fail-on-unknown-properties: false

# =============== POSTGRESQL DATASOURCES ===============
postgresql:
  datasources:
    pba:
      jdbc-url: ${PBA_URL:jdbc:postgresql://localhost:5432/pba_db?reWriteBatchedInserts=true&tcpKeepAlive=true}
      username: ${PBA_USERNAME:postgres}
      password: ${PBA_PASSWORD:password}
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: "PostgreSQL-PBA-Pool"
        maximum-pool-size: 8
        minimum-idle: 8
        connection-timeout: 30000
        idle-timeout: 1200000
        max-lifetime: 1680000
        keepalive-time: 300000
        leak-detection-threshold: 600000
        auto-commit: false
        register-mbeans: true
        connection-init-sql: "SET statement_timeout = '30min'; SET work_mem = '64MB'"
        data-source-properties:
          tcpKeepAlive: true
          cachePrepStmts: true
          prepStmtCacheSize: 250
          prepStmtCacheSqlLimit: 2048
          useServerPrepStmts: true

    mda:
      jdbc-url: ${MDA_URL:jdbc:postgresql://localhost:5432/mda_db?reWriteBatchedInserts=true&tcpKeepAlive=true}
      username: ${MDA_USERNAME:postgres}
      password: ${MDA_PASSWORD:password}
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: "PostgreSQL-MDA-Pool"
        maximum-pool-size: 5
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 1200000
        max-lifetime: 1680000
        keepalive-time: 300000
        leak-detection-threshold: 600000
        auto-commit: false
        register-mbeans: true
        connection-init-sql: "SET statement_timeout = '30min'; SET work_mem = '64MB'"
        data-source-properties:
          tcpKeepAlive: true
          cachePrepStmts: true
          prepStmtCacheSize: 250
          prepStmtCacheSqlLimit: 2048
          useServerPrepStmts: true

    santa-rosa:
      jdbc-url: ${SANTA_ROSA_URL:jdbc:postgresql://localhost:5432/santa_rosa_db?reWriteBatchedInserts=true&tcpKeepAlive=true}
      username: ${SANTA_ROSA_USERNAME:postgres}
      password: ${SANTA_ROSA_PASSWORD:password}
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: "PostgreSQL-SantaRosa-Pool"
        maximum-pool-size: 5
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 1200000
        max-lifetime: 1680000
        keepalive-time: 300000
        leak-detection-threshold: 600000
        auto-commit: false
        register-mbeans: true
        connection-init-sql: "SET statement_timeout = '30min'; SET work_mem = '64MB'"
        data-source-properties:
          tcpKeepAlive: true
          cachePrepStmts: true
          prepStmtCacheSize: 250
          prepStmtCacheSqlLimit: 2048
          useServerPrepStmts: true

    chaco:
      jdbc-url: ${CHACO_URL:jdbc:postgresql://localhost:5432/chaco_db?reWriteBatchedInserts=true&tcpKeepAlive=true}
      username: ${CHACO_USERNAME:postgres}
      password: ${CHACO_PASSWORD:password}
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: "PostgreSQL-Chaco-Pool"
        maximum-pool-size: 5
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 1200000
        max-lifetime: 1680000
        keepalive-time: 300000
        leak-detection-threshold: 600000
        auto-commit: false
        register-mbeans: true
        connection-init-sql: "SET statement_timeout = '30min'; SET work_mem = '64MB'"
        data-source-properties:
          tcpKeepAlive: true
          cachePrepStmts: true
          prepStmtCacheSize: 250
          prepStmtCacheSqlLimit: 2048
          useServerPrepStmts: true

    entre-rios:
      jdbc-url: ${ENTRE_RIOS_URL:jdbc:postgresql://localhost:5432/entre_rios_db?reWriteBatchedInserts=true&tcpKeepAlive=true}
      username: ${ENTRE_RIOS_USERNAME:postgres}
      password: ${ENTRE_RIOS_PASSWORD:password}
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: "PostgreSQL-EntreRios-Pool"
        maximum-pool-size: 5
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 1200000
        max-lifetime: 1680000
        keepalive-time: 300000
        leak-detection-threshold: 600000
        auto-commit: false
        register-mbeans: true
        connection-init-sql: "SET statement_timeout = '30min'; SET work_mem = '64MB'"
        data-source-properties:
          tcpKeepAlive: true
          cachePrepStmts: true
          prepStmtCacheSize: 250
          prepStmtCacheSqlLimit: 2048
          useServerPrepStmts: true

    formosa:
      jdbc-url: ${FORMOSA_URL:jdbc:postgresql://localhost:5432/formosa_db?reWriteBatchedInserts=true&tcpKeepAlive=true}
      username: ${FORMOSA_USERNAME:postgres}
      password: ${FORMOSA_PASSWORD:password}
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: "PostgreSQL-Formosa-Pool"
        maximum-pool-size: 5
        minimum-idle: 5
        connection-timeout: 30000
        idle-timeout: 1200000
        max-lifetime: 1680000
        keepalive-time: 300000
        leak-detection-threshold: 600000
        auto-commit: false
        register-mbeans: true
        connection-init-sql: "SET statement_timeout = '30min'; SET work_mem = '64MB'"
        data-source-properties:
          tcpKeepAlive: true
          cachePrepStmts: true
          prepStmtCacheSize: 250
          prepStmtCacheSqlLimit: 2048
          useServerPrepStmts: true

# Configuración del servidor
server:
  port: ${SERVER_PORT:8080}
  tomcat:
    max-connections: 50
    threads:
      max: 20
      min-spare: 5
    connection-timeout: 30000
    max-http-post-size: 52428800
  error:
    include-message: always
    include-binding-errors: always

# =============== CONFIGURACIÓN DE QUERY REGISTRY (NUEVA) ===============
app:
  query-registry:
    #  Auto-descubrimiento de queries
    auto-scan-enabled: ${AUTO_SCAN_QUERIES:true}        # Escanear /resources/querys/ automáticamente
    queries-path: ${QUERIES_PATH:classpath:querys/}     # Ruta donde buscar queries
    file-extensions: ${QUERY_EXTENSIONS:sql}            # Extensiones válidas (sql)

    #  Comportamiento al iniciar
    auto-analyze-on-startup: ${AUTO_ANALYZE_QUERIES:true}  # Analizar queries al iniciar
    scan-on-startup: ${SCAN_ON_STARTUP:true}               # Escanear directorio al iniciar
    update-existing: ${UPDATE_EXISTING:true}               # Actualizar queries existentes

    #  Configuración de archivos
    h2-file-path: ${H2_FILE_PATH:./data/query_metadata}    # Ubicación del archivo H2
    backup-enabled: ${BACKUP_ENABLED:true}                 # Backup automático
    backup-interval-hours: ${BACKUP_INTERVAL:24}           # Cada 24 horas

    #  Upload de queries dinámico
    upload-enabled: ${UPLOAD_ENABLED:true}                 # Permitir upload de queries
    upload-path: ${UPLOAD_PATH:./uploads/queries/}         # Donde guardar queries subidas
    max-file-size: ${MAX_QUERY_FILE_SIZE:1MB}              # Tamaño máximo por query
    allowed-extensions: ${ALLOWED_EXTENSIONS:sql}           # Solo SQL

  query-analyzer:
    version: "1.0"                                          # Versión del analizador
    enable-cache: false                                     # Sin cache en memoria (H2 es el cache)
    fallback-strategy: CONSOLIDACION_SIMPLE                # Fallback si falla análisis
    max-analysis-time-ms: 5000                             # Timeout para análisis complejos

  # Configuración de consolidación
  consolidacion:
    default-strategy: "inteligente"       # inteligente | provincia | completa | temporal
    max-grouping-fields: 5               # Máximo campos de agrupación
    min-numeric-fields: 1                # Mínimo campos numéricos para consolidar

  limits:
    max-records-sync: 1000000000         # Para que consultas de hasta 5000 usen procesamiento síncrono
    max-records-total: 100000       # Máximo absoluto de registros
    max-records-display: 10000      # Máximo para endpoints de consulta (Postman-friendly)
    max-concurrent-queries: 10      # Máximo de consultas concurrentes

  batch:
    size: 10000
    parallel-threshold-per-province: 50000    # <50K → Paralelo completo
    parallel-threshold-total: 300000          # <300K → Paralelo completo
    massive-threshold-per-province: 200000    # >200K → Secuencial
    max-parallel-provinces: 6                 # Para modo híbrido

  # Configuración para threads asíncronos
  async:
    thread-pool-size: 10

# Configuración de logging
logging:
  level:
    # Nivel general - reducir ruido
    org.transito_seguro: INFO

    # BatchProcessor - logs detallados de progreso
    org.transito_seguro.component.BatchProcessor: INFO

    # Otros componentes - reducir ruido
    org.transito_seguro.repository.impl.InfraccionesRepositoryImpl: DEBUG
    org.transito_seguro.component.ParametrosProcessor: DEBUG
    org.transito_seguro.component.StreamingFormatoConverter: DEBUG

    # Spring JDBC - solo errores
    org.springframework.jdbc: WARN
    org.springframework.jdbc.core.JdbcTemplate: WARN
    org.springframework.jdbc.datasource: WARN

    # Hibernate
    org.hibernate.SQL: ${HIBERNATE_SQL_LOG:INFO}
    org.hibernate.type: ${HIBERNATE_TYPE_LOG:WARN}

    # Otros
    com.zaxxer.hikari: INFO
    org.postgresql: WARN
    org.h2: INFO

  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"

# Actuator para monitoreo
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,info,h2,query-registry
  endpoint:
    health:
      show-details: when_authorized
    metrics:
      enabled: true
    # Endpoint personalizado para Query Registry
    query-registry:
      enabled: true

# =============== CONFIGURACIÓN POR AMBIENTE ===============
---
spring:
  config:
    activate:
      on-profile: development

  h2:
    console:
      enabled: true

  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true

app:
  query-registry:
    scan-on-startup: true          # Escanear siempre en desarrollo
    upload-enabled: true           # Permitir uploads en desarrollo

logging:
  level:
    org.transito_seguro: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

---
spring:
  config:
    activate:
      on-profile: production

  datasource:
    # En producción, usar H2 embebido más robusto
    jdbc-url: jdbc:h2:file:/opt/app/data/query_metadata;DB_CLOSE_ON_EXIT=FALSE;AUTO_SERVER=FALSE
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5

  h2:
    console:
      enabled: false  # Deshabilitar consola en producción

  jpa:
    show-sql: false

app:
  query-registry:
    backup-enabled: true
    backup-interval-hours: 12      # Backup cada 12 horas en producción
    upload-enabled: false          # Sin uploads directos en producción

logging:
  level:
    org.transito_seguro: INFO
    org.hibernate.SQL: WARN

---
spring:
  config:
    activate:
      on-profile: testing

  datasource:
    # H2 en memoria para tests
    jdbc-url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE

  jpa:
    hibernate:
      ddl-auto: create-drop  # Recrear schema en cada test
    show-sql: true

app:
  query-registry:
    auto-analyze-on-startup: false  # No auto-analizar en tests
    scan-on-startup: false          # No escanear en tests
    upload-enabled: false           # No uploads en tests